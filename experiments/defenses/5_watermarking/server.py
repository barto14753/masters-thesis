from flask import Flask, request, jsonify
import ollama
import base64
import time
import logging
from watermark import sign_message, extract_metadata
import threading
import difflib

app = Flask(__name__)

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

AUTHORIZED_USERS = {
    "user1": "password123",
    "admin": "supersecret"
}

# Simple in-memory database to store (original_rhyme, user, timestamp)
RHYME_DB = set()
RHYME_DB_LOCK = threading.Lock()

def check_auth(auth_header):
    """Validates the Basic Auth header."""
    if not auth_header:
        return None
    
    try:
        auth_type, credentials = auth_header.split()
        if auth_type.lower() != "basic":
            return None

        decoded = base64.b64decode(credentials).decode()
        username, password = decoded.split(":", 1)
        if username in AUTHORIZED_USERS and AUTHORIZED_USERS[username] == password:
            return username
    except Exception:
        return None
    
    return None

@app.route('/rhyme', methods=['POST'])
def generate_rhyme():
    """Generates a short rhyme with a digital watermark in the second line."""
    user = check_auth(request.headers.get("Authorization"))
    if not user:
        return jsonify({"error": "Unauthorized"}), 401

    topic = request.json.get("topic", "default")
    response = ollama.chat(model="rhymegen-model", messages=[{"role": "user", "content": f"Write a short rhyme about {topic}"}])
    rhyme_lines = response["message"]["content"].split("\n")

    if len(rhyme_lines) < 2:
        logger.warning("Generated rhyme has fewer than 2 lines, appending empty lines.")
        rhyme_lines.append("")  # Ensure at least 2 lines exist

    # Save original rhyme (before watermark) in DB with user and timestamp
    original_rhyme = "\n".join(rhyme_lines)
    timestamp = int(time.time())
    with RHYME_DB_LOCK:
        RHYME_DB.add((original_rhyme, user, timestamp))

    # Generate watermark and insert it into the second line
    signature = sign_message(original_rhyme, user, timestamp)
    rhyme_lines[1] = signature  # Overwrite the second line

    final_rhyme = "\n".join(rhyme_lines)

    logger.info(f"Generated rhyme for {user} on topic '{topic}'")
    logger.info(f"Final rhyme:\n{final_rhyme}")

    return jsonify({"rhyme": final_rhyme, "user": user, "notice": "This rhyme was generated by AI RhymeGen."})

@app.route('/validate', methods=['POST'])
def validate_rhyme():
    """Validates if a rhyme was generated by the system and extracts metadata or checks for plagiarism."""
    rhyme_text = request.json.get("rhyme", "")
    metadata = extract_metadata(rhyme_text)
    if metadata:
        return jsonify({"valid": True, "user": metadata["user"], "timestamp": metadata["timestamp"]})
    # If no watermark, check for similarity (plagiarism detection)
    best_match = None
    best_ratio = 0.0
    with RHYME_DB_LOCK:
        for entry in RHYME_DB:
            original, user, timestamp = entry
            seq = difflib.SequenceMatcher(None, rhyme_text, original)
            ratio = seq.ratio()
            if ratio > best_ratio:
                best_ratio = ratio
                best_match = entry
    if best_match and best_ratio >= 0.75:
        return jsonify({
            "valid": False,
            "plagiarism": True,
            "user": best_match[1],
            "timestamp": best_match[2],
            "original": best_match[0],
            "copied_percent": round(best_ratio * 100, 2),
            "notice": "At least 75% of the content matches a previously generated rhyme."
        })
    return jsonify({"valid": False, "error": "Invalid or missing watermark, and no significant match found in server database."}), 400

if __name__ == '__main__':
    app.run(debug=True)
